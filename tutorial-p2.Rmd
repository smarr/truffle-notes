<span style="color: red; font-weight:bold">Draft: Please Do Not Share!</span>

Truffle-lize Your Language Implementation in 5 Easy Steps
=========================================================

# Step 2: Adding Bit Operations To Golo

As discussed in the previous [post][0], we will eventually try to improve the
numerical performance of Golo by using Truffle. However, for the chosen
Mandelbrot benchmark we first need to add support for bit operations to Golo.
The main reason for doing this exercise first is to get a better understanding
of how the current Golo implementation works. It was designed as dynamic
language to exploit the `invokedynamic` support of the JVM. To be able to do
that, Golo uses a bytecode compilation approach. So, instead of using the
abstract-syntax-tree (AST) the parser creates from the source program directly
for execution, the AST is first compiled to bytecodes, which are then executed
by the JVM. While this post will dive into some of the details, an earlier
[paper on Golo][1] can provide a few more details.

## Adapting the Parser

Golo's parser is built with [JavaCC][2]. Thus, the Golo grammar is specified
in some [extended variant of BNF][3]. The parser generated by JavaCC takes
`.golo` files and produces ASTs, which then are transformed in multiple steps
to bytecodes.

To add bit operations, we essentially need to add new binary operators to the
language. Currently, Golo does neither support *xor* (`^`), *left shift*
(`<<`), nor *or* (`|`). To avoid messing with the language designer's desired
aesthetics, we will use the simplest and ugliest solution here and just hope
they won't adopt it, but find something that fits in the language instead. So,
we are simply adding the three keywords `bitXOR`, `bitLSHIFT`, and `bitOR`.

This means, we extend the Golo grammar by adding `BIT_OPERATOR` to the
definition of [`TOKEN`][4]:

```
TOKEN :
{
  < MULTIPLICATIVE_OPERATOR: ("*" | "/" | "%") >
  |
  < BIT_OPERATOR: ("bitOR" | "bitLSHIFT" | "bitXOR") >
  |
// ...
```

Now, the parser can recognize these tokens in a program. To parse them as part
of an expression, we need to adapt how binary expressions, i.e., expressions
with two operands are parsed. In many languages, bit operators have the highest
precedence. Thus, we adapt the rule for `MultiplicativeExpression`, which
currently is the one that then falls back to unary expressions. The new rule
for `BitExpression`s is listed below. It essentially means that the left
operand of a `BitExpression` is parsed as a `UnaryExpression`, then there might
by blank lines, then we need a `BIT_OPERATOR`, and eventually we expect the
right operand, which itself can be some invocation.

```
void BitExpression() #void:
{
  Token token = null;
}
{
  UnaryExpression()
  (
    LOOKAHEAD(2) (BlankLine())? token=<BIT_OPERATOR> (BlankLine())? InvocationExpression()
    {
      jjtThis.addOperator(token.image);
    }
  )* #BitExpression(token != null)
}
```

The JavaCC parser uses these rules to produce code that eventually instantiates
an [`ASTBitExpression` object][5], which holds the operator and the child
expressions. As we see in later posts, this structure is already very close to
the Truffle ASTs we will use for execution. For basic Golo however, we first
need some more changes to get the bit operations working.

## Implementing The Bit Operations

The basic operators are implemented in the `OperatorSupport` class. We merely
add the following three functions:

```java
public static Object bit_lshift(Integer a, Integer b) {
  return a << b;
}

public static Object bit_or(Integer a, Integer b) {
  return a | b;
}

public static Object bit_xor(Integer a, Integer b) {
  return a ^ b;
}
```

One might notice that all arguments and return values are proper objects. In
our case, the arguments are `Integer` instead of the primitive `int`. Thus, the
values on which basic operations are performed need to be boxed. The main
reason for this design is most likely the use of `invokedynamic` and the
benefits of a simple uniform representation.

## Using `InvokeDynamic` To Execute Bit Operations

Before these methods can be invoked, the necessary bytecode needs to be
generated. Before compiling to bytecode, Golo uses an intermediate
representation that ensures some basic properties of the language and
simplifies bytecode generation. For the bit operations, we needed to add a
[`visit(.)` method][6] for `ASTBitExpression` in the visitor that transforms
the JavaCC AST into the Golo intermediate representation. For brevity, we skip
over the details, which can be seen in the corresponding [patch][6].

For the bytecode generation, we can have a look at the
`JavaBytecodeGenerationGoloIrVisitor` class. The following method
handles all binary operations, which includes our bit operators:

```java
void genericBinaryOperator(BinaryOperation binaryOperation, OperatorType operatorType) {
  binaryOperation.getLeftExpression().accept(this);
  binaryOperation.getRightExpression().accept(this);
  if (!isMethodCall(binaryOperation)) {
    String name = operatorType.name().toLowerCase();
    methodVisitor.visitInvokeDynamicInsn(
      name, goloFunctionSignature(2), OPERATOR_HANDLE, (Integer) 2);
  }
}
```

While this is a small and simple method, one can get a bit of the feeling of
how the bytecode generation works. The first thing the method does is to take
the left expression and generate bytecode for it. Afterwards, it generates the
bytecode for the right expression. To fully understand what this means, we need
to recall that the JVM is essentially a stack machine. So, after the bytecode
was executed that belongs to the left expression, the result will remain on the
stack. This is not obvious here, and only implied by the JVM's execution
semantics. Similarly, the right hand side will also be evaluated to a value on
the stack. In the simplest case, this means, there are now two values on the
stack.

For our bit operations, the next step is crucial. It will take the operator
type and convert its name into lower case, which then corresponds to our
`bit_xor`, `bit_lshift`, or `bit_or` methods. Afterwards, it creates an
`invokedynamic` call to these methods. This hides much of the machinery of the
underlying infrastructure. But, I hope it gives an impression of what happens
during compilation as well as later during execution.

## Conclusion

To summarize, Golo uses a three-step approach to bytecode generation. In the
first step, the JavaCC-based parser generates and AST. This AST is than
transformed in a more convenient intermediate representation, which is then in
a third step compiled to bytecodes.

As we could see above, Golo relies on `invokedynamic` and uses a uniform
Object-based representation for all values.

In the next post, we will finally start with the basics of how to apply Truffle
to Golo and implement as sufficient subset of it to run a classic Fibonacci
computation.

<!--
- step 3: make fibonnaci work
  -> interpretation mindset vs. compilation mindset

- step 4: make mandelbrot work

- step 5: optimize


get graal
http://lafo.ssw.uni-linz.ac.at/builds

Needs -G:GraphPE to avoid NPE

graalvm-jdk1.8.0/bin/java -G:-GraphPE -Xms256m -Xmx1024M -Xss1024M -Xbootclasspath/a:/Users/smarr/Projects/PostDoc/Lyon/golo-lang/build/install/golo/lib/truffle-api-0.8.jar -classpath /Users/smarr/Projects/PostDoc/Lyon/golo-lang/build/install/golo/lib/golo-3.0.0-incubation-SNAPSHOT.jar:/Users/smarr/Projects/PostDoc/Lyon/golo-lang/build/install/golo/lib/asm-5.0.4.jar:/Users/smarr/Projects/PostDoc/Lyon/golo-lang/build/install/golo/lib/jcommander-1.48.jar:/Users/smarr/Projects/PostDoc/Lyon/golo-lang/build/install/golo/lib/txtmark-0.13.jar:/Users/smarr/Projects/PostDoc/Lyon/golo-lang/build/install/golo/lib/json-simple-1.1.1.jar fr.insalyon.citi.golo.cli.Main golo --truffle --files samples/mandelbrot.golo
--> 

[0]: http://todo
[1]: https://julien.ponge.org/files/publications/golo-pppj13.pdf
[2]: https://javacc.java.net/
[3]: https://en.wikipedia.org/wiki/Extended_Backus%E2%80%93Naur_Form
[4]: https://github.com/smarr/golo-lang/commit/75bc324f115e8a5480dc5a5b8cedb8b471f366f2#diff-5
[5]: https://github.com/smarr/golo-lang/commit/75bc324f115e8a5480dc5a5b8cedb8b471f366f2#diff-1
[6]: https://github.com/smarr/golo-lang/commit/75bc324f115e8a5480dc5a5b8cedb8b471f366f2#diff-0
